//Compiled with gcc, -O3 flags

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>

#define ROLLA roll = (uint16_t) rand(); \
        \
       asm( \
        "mov di, 1 ;\n" \
        "test %[Roll], 0b0011000000000000 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        "test %[Roll], 0b0000110000000000 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        "test %[Roll], 0b0000001100000000 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        "test %[Roll], 0b0000000011000000 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        "test %[Roll], 0b0000000000110000 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        "test %[Roll], 0b0000000000001100 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        "test %[Roll], 0b0000000000000011 ;\n" \
        "mov cx, 0 ;\n" \
        "cmovz cx, di ;\n" \
        "add %[Result], cx;\n" \
        : [Result] "+r" (result) \
        : [Roll] "r" (roll) \
        : "cc", "cx", "di" \
       );

int rolling(){
    uint16_t result = 0;
    uint16_t roll = 0;
        /*
        Random number generation is usually the most time-consuming part of a dice roll,
        ESPECIALLY for true random number generation (not the case here).
        We are very lucky that the paralysis chance is EXACTLY 1/4:
        We can model a 4-sided dice roll with a 2-bit number, a-power-of-two bits.
        That means we can get a single rand() call and divide the bytes generated by it in multiple rolls,
        using bitmaps that zero out bytes we are not interested in.
        */

        /*
        Why are we casting rand() in such way?
        rand()'s range in Linux is 0 to 2^31-1,
        rand()'s range in Windows is 0 to 2^15-1.
        That means:
        1) Windows targets will generate zeros in the upper part of a 32-bit number, screwing up the result.
        2) The upper most bit will always be 0, meaning one of the dice will have 2 sides instead of 4.
        3) You can minimize rand() calls even further by getting a proper PRNG that generates 32 or 64 bytes.
        */

    /*
    Also, the assembly snippet didn't really bring much of an improvement over -O3 flags.
    */

//FUCK A FOR LOOP, WE COPYING THE CODE 31 TIMES INSTEAD
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA
    ROLLA


        /*
        The assembly snippet does the same thing as this:
        It splits the 16-bit number into seven 2-bit dice (the last one is garbage for our purposes)
        Checks each one for 00 using a bitmask (00 can be interpreted as 1, since the possibilities are 00, 01, 10, 11)
        If 00 is the result, increments the succesfull rolls by 1.
        At the end, we can return result.


        uint16_t dice = roll & bitmap1; 
        if (!dice){
            result++;
        }
        dice = roll & bitmap2;
        if (!dice){
            result++;
        }
        dice = roll & bitmap3;
        if (!dice){
            result++;
        }
        dice = roll & bitmap4;
        if (!dice){
            result++;
        }
        dice = roll & bitmap5;
        if (!dice){
            result++;
        }
        dice = roll & bitmap6;
        if (!dice){
            result++;
        }
        dice = roll & bitmap7;
        if (!dice){
            result++;
        }
        */
        
    //} 
    return result;
}

int main(){
    srand((unsigned)time(NULL));
    clock_t start = clock();
    puts("Started!");

    uint16_t max_roll = 0;
    for (int attempt = 1; attempt <= 100000000; attempt++){
      uint16_t current = rolling();
      if (current > max_roll){
        max_roll = current;
      }  
    }

    //Measures the time it took for 1.000.000.000 attempts.
    clock_t end = clock();
    double time_delta = ((double) end - start) / CLOCKS_PER_SEC; 
    puts("Number of attempts: 1.000.000.000");
    printf("Max roll: %d\n", max_roll);
    printf("Time taken: %f seconds\n", time_delta);
    return 0;
}
