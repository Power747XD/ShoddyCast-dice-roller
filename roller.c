//Compiled with gcc, -O3 flags

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>

#define bitmap1 0b0011000000000000
#define bitmap2 0b0000110000000000
#define bitmap3 0b0000001100000000
#define bitmap4 0b0000000011000000
#define bitmap5 0b0000000000110000
#define bitmap6 0b0000000000001100
#define bitmap7 0b0000000000000011

int roll(){
    uint32_t result = 0;
    uint16_t dice = 0;
        /*
        Random number generation is usually the most time-consuming part of a dice roll,
        ESPECIALLY for true random number generation (not the case here).
        We are very lucky that the paralysis chance is EXACTLY 1/4:
        We can model a 4-sided dice roll with a 2-bit number, a-power-of-two bits.
        That means we can get a single rand() call and divide the bytes generated by it in multiple rolls,
        using bitmaps that zero out bytes we are not interested in.
        */
    for (int i = 0; i <= 30; i++){ //231 / 7 = 31
        uint16_t roll = (uint16_t) rand();
        /*
        Why are we casting rand() in such way?
        rand()'s range in Linux is 0 to 2^31-1,
        rand()'s range in Windows is 0 to 2^15-1.
        That means:
        1) Windows targets will generate zeros in the upper part of a 32-bit number, screwing up the result.
        2) The upper most bit will always be 0, meaning one of the dice will have 2 sides instead of 4.
        */
        dice = roll & bitmap1; 
        if (!dice){ //Hand-written assembly can probably shave off lots of time by removing CMP instructions.
            result++;
        }
        dice = roll & bitmap2;
        if (!dice){
            result++;
        }
        dice = roll & bitmap3;
        if (!dice){
            result++;
        }
        dice = roll & bitmap4;
        if (!dice){
            result++;
        }
        dice = roll & bitmap5;
        if (!dice){
            result++;
        }
        dice = roll & bitmap6;
        if (!dice){
            result++;
        }
        dice = roll & bitmap7;
        if (!dice){
            result++;
        }
    } 
    return result;
}

int main(){
    srand((unsigned)time(NULL));
    clock_t start = clock();
    puts("Started!");

    uint8_t max_roll = 0;
    for (int attempt = 1; attempt <= 1000000000; attempt++){
      uint8_t current = roll();
      if (current > max_roll){
        max_roll = current;
      }  
    }

    //Measures the time it took for 1.000.000.000 attempts.
    clock_t end = clock();
    double time_delta = ((double) end - start) / CLOCKS_PER_SEC; 
    puts("Number of attempts: 1.000.000.000");
    printf("Max roll: %d\n", max_roll);
    printf("Time taken: %f seconds\n", time_delta);
    return 0;
}
